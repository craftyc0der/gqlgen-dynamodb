// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/craftyc0der/gqlgen-dynamodb/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	ArrayInputUnique  func(ctx context.Context, obj interface{}, next graphql.Resolver, fieldName string, exceptionRegex *string) (res interface{}, err error)
	AuthorizedRole    func(ctx context.Context, obj interface{}, next graphql.Resolver, serviceRoles []string, userRoles []string) (res interface{}, err error)
	CustomResolver    func(ctx context.Context, obj interface{}, next graphql.Resolver, packageArg string, function string) (res interface{}, err error)
	CustomSubquery    func(ctx context.Context, obj interface{}, next graphql.Resolver, packageArg string, function string) (res interface{}, err error)
	DefaultValue      func(ctx context.Context, obj interface{}, next graphql.Resolver, envVar *string, static *string, variable *string) (res interface{}, err error)
	DynamodbColumn    func(ctx context.Context, obj interface{}, next graphql.Resolver, fieldName string, fieldType string, jsonName *string) (res interface{}, err error)
	DynamodbHashKey   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	DynamodbQuery     func(ctx context.Context, obj interface{}, next graphql.Resolver, table string, projectionExpression *string, index *string, limit *int, sortColumn *string, sortAsc *bool, scanIndexBackward *bool, consistentRead *bool, insert *bool, update *bool, delete *bool, updateConditionExpression *string, updateConditionValues []string, updateConditionError *string, deleteConditionExpression *string, deleteConditionValues []string, deleteConditionError *string, preQueryPackage *string, preQueryFunction *string, postQueryPackage *string, postQueryFunction *string) (res interface{}, err error)
	DynamodbRangeKey  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	DynamodbSubquery  func(ctx context.Context, obj interface{}, next graphql.Resolver, foreignHashKey string, foreignHashKeyRequired bool, hashKeyModelName string, hashKeyFieldName string, hashKeyFieldType string, parentHashKeyModelName string, foreignRangeKey *string, foreignRangeKeyRequired *bool, rangeKeyModelName *string, rangeKeyFieldName *string, rangeKeyFieldType *string, parentRangeKeyModelName *string, className string, table string, limit *int) (res interface{}, err error)
	Example           func(ctx context.Context, obj interface{}, next graphql.Resolver, value string) (res interface{}, err error)
	Hash              func(ctx context.Context, obj interface{}, next graphql.Resolver, fieldName string) (res interface{}, err error)
	Immutable         func(ctx context.Context, obj interface{}, next graphql.Resolver, errorMessage string) (res interface{}, err error)
	MutationCondition func(ctx context.Context, obj interface{}, next graphql.Resolver, expression string) (res interface{}, err error)
	Timestamp         func(ctx context.Context, obj interface{}, next graphql.Resolver, immutable bool) (res interface{}, err error)
	Uuid              func(ctx context.Context, obj interface{}, next graphql.Resolver, hashKey bool) (res interface{}, err error)
}

type ComplexityRoot struct {
	ApplicationCompany struct {
		CompanyID   func(childComplexity int) int
		CompanyName func(childComplexity int) int
		CreateDate  func(childComplexity int) int
	}

	ApplicationCompanyList struct {
		Items func(childComplexity int) int
	}

	ApplicationCustomData struct {
		Bar func(childComplexity int) int
		Foo func(childComplexity int) int
	}

	ApplicationCustomSource struct {
		Custom func(childComplexity int) int
	}

	ApplicationUser struct {
		Company    func(childComplexity int) int
		CompanyID  func(childComplexity int) int
		CreateDate func(childComplexity int) int
		CustomData func(childComplexity int) int
		Languages  func(childComplexity int) int
		UserID     func(childComplexity int) int
		UserName   func(childComplexity int) int
	}

	ApplicationUserLanguage struct {
		UserID       func(childComplexity int) int
		UserLanguage func(childComplexity int) int
	}

	ApplicationUserLanguageList struct {
		Items func(childComplexity int) int
	}

	ApplicationUserList struct {
		Items func(childComplexity int) int
	}

	Mutation struct {
		CreateApplicationUser         func(childComplexity int, userName string, companyID string) int
		CreateApplicationUserLanguage func(childComplexity int, userID string, userLanguage string) int
		DeleteApplicationUserLanguage func(childComplexity int, userID string, userLanguage string) int
		UpdateApplicationUser         func(childComplexity int, userID string, userName string, companyID string) int
	}

	Query struct {
		GetApplicationUser     func(childComplexity int, userID string) int
		ListApplicationCompany func(childComplexity int) int
		SearchApplicationUser  func(childComplexity int, userName string) int
	}
}

type MutationResolver interface {
	CreateApplicationUser(ctx context.Context, userName string, companyID string) (*model.ApplicationUserList, error)
	UpdateApplicationUser(ctx context.Context, userID string, userName string, companyID string) (*model.ApplicationUserList, error)
	CreateApplicationUserLanguage(ctx context.Context, userID string, userLanguage string) (*model.ApplicationUserLanguageList, error)
	DeleteApplicationUserLanguage(ctx context.Context, userID string, userLanguage string) (*model.ApplicationUserLanguageList, error)
}
type QueryResolver interface {
	GetApplicationUser(ctx context.Context, userID string) (*model.ApplicationUserList, error)
	SearchApplicationUser(ctx context.Context, userName string) (*model.ApplicationUserList, error)
	ListApplicationCompany(ctx context.Context) (*model.ApplicationCompanyList, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ApplicationCompany.companyID":
		if e.complexity.ApplicationCompany.CompanyID == nil {
			break
		}

		return e.complexity.ApplicationCompany.CompanyID(childComplexity), true

	case "ApplicationCompany.companyName":
		if e.complexity.ApplicationCompany.CompanyName == nil {
			break
		}

		return e.complexity.ApplicationCompany.CompanyName(childComplexity), true

	case "ApplicationCompany.createDate":
		if e.complexity.ApplicationCompany.CreateDate == nil {
			break
		}

		return e.complexity.ApplicationCompany.CreateDate(childComplexity), true

	case "ApplicationCompanyList.items":
		if e.complexity.ApplicationCompanyList.Items == nil {
			break
		}

		return e.complexity.ApplicationCompanyList.Items(childComplexity), true

	case "ApplicationCustomData.bar":
		if e.complexity.ApplicationCustomData.Bar == nil {
			break
		}

		return e.complexity.ApplicationCustomData.Bar(childComplexity), true

	case "ApplicationCustomData.foo":
		if e.complexity.ApplicationCustomData.Foo == nil {
			break
		}

		return e.complexity.ApplicationCustomData.Foo(childComplexity), true

	case "ApplicationCustomSource.custom":
		if e.complexity.ApplicationCustomSource.Custom == nil {
			break
		}

		return e.complexity.ApplicationCustomSource.Custom(childComplexity), true

	case "ApplicationUser.company":
		if e.complexity.ApplicationUser.Company == nil {
			break
		}

		return e.complexity.ApplicationUser.Company(childComplexity), true

	case "ApplicationUser.companyID":
		if e.complexity.ApplicationUser.CompanyID == nil {
			break
		}

		return e.complexity.ApplicationUser.CompanyID(childComplexity), true

	case "ApplicationUser.createDate":
		if e.complexity.ApplicationUser.CreateDate == nil {
			break
		}

		return e.complexity.ApplicationUser.CreateDate(childComplexity), true

	case "ApplicationUser.customData":
		if e.complexity.ApplicationUser.CustomData == nil {
			break
		}

		return e.complexity.ApplicationUser.CustomData(childComplexity), true

	case "ApplicationUser.languages":
		if e.complexity.ApplicationUser.Languages == nil {
			break
		}

		return e.complexity.ApplicationUser.Languages(childComplexity), true

	case "ApplicationUser.userID":
		if e.complexity.ApplicationUser.UserID == nil {
			break
		}

		return e.complexity.ApplicationUser.UserID(childComplexity), true

	case "ApplicationUser.userName":
		if e.complexity.ApplicationUser.UserName == nil {
			break
		}

		return e.complexity.ApplicationUser.UserName(childComplexity), true

	case "ApplicationUserLanguage.userID":
		if e.complexity.ApplicationUserLanguage.UserID == nil {
			break
		}

		return e.complexity.ApplicationUserLanguage.UserID(childComplexity), true

	case "ApplicationUserLanguage.userLanguage":
		if e.complexity.ApplicationUserLanguage.UserLanguage == nil {
			break
		}

		return e.complexity.ApplicationUserLanguage.UserLanguage(childComplexity), true

	case "ApplicationUserLanguageList.items":
		if e.complexity.ApplicationUserLanguageList.Items == nil {
			break
		}

		return e.complexity.ApplicationUserLanguageList.Items(childComplexity), true

	case "ApplicationUserList.items":
		if e.complexity.ApplicationUserList.Items == nil {
			break
		}

		return e.complexity.ApplicationUserList.Items(childComplexity), true

	case "Mutation.createApplicationUser":
		if e.complexity.Mutation.CreateApplicationUser == nil {
			break
		}

		args, err := ec.field_Mutation_createApplicationUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApplicationUser(childComplexity, args["userName"].(string), args["companyID"].(string)), true

	case "Mutation.createApplicationUserLanguage":
		if e.complexity.Mutation.CreateApplicationUserLanguage == nil {
			break
		}

		args, err := ec.field_Mutation_createApplicationUserLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApplicationUserLanguage(childComplexity, args["userID"].(string), args["userLanguage"].(string)), true

	case "Mutation.deleteApplicationUserLanguage":
		if e.complexity.Mutation.DeleteApplicationUserLanguage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApplicationUserLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApplicationUserLanguage(childComplexity, args["userID"].(string), args["userLanguage"].(string)), true

	case "Mutation.updateApplicationUser":
		if e.complexity.Mutation.UpdateApplicationUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateApplicationUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApplicationUser(childComplexity, args["userID"].(string), args["userName"].(string), args["companyID"].(string)), true

	case "Query.getApplicationUser":
		if e.complexity.Query.GetApplicationUser == nil {
			break
		}

		args, err := ec.field_Query_getApplicationUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetApplicationUser(childComplexity, args["userID"].(string)), true

	case "Query.listApplicationCompany":
		if e.complexity.Query.ListApplicationCompany == nil {
			break
		}

		return e.complexity.Query.ListApplicationCompany(childComplexity), true

	case "Query.searchApplicationUser":
		if e.complexity.Query.SearchApplicationUser == nil {
			break
		}

		args, err := ec.field_Query_searchApplicationUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchApplicationUser(childComplexity, args["userName"].(string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputTableBooleanFilterInput,
		ec.unmarshalInputTableBooleanKeyInput,
		ec.unmarshalInputTableFloatFilterInput,
		ec.unmarshalInputTableFloatKeyInput,
		ec.unmarshalInputTableIntFilterInput,
		ec.unmarshalInputTableIntKeyInput,
		ec.unmarshalInputTableStringFilterInput,
		ec.unmarshalInputTableStringKeyInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema-directives.graphql", Input: `directive @authorizedRole(
	serviceRoles: [String!]!
	userRoles: [String!]!
) on FIELD_DEFINITION

directive @customResolver(
	package: String!
	function: String!
) on FIELD_DEFINITION

directive @customSubquery(
	package: String!
	function: String!
) on FIELD_DEFINITION

directive @defaultValue(
	envVar: String
	static: String
	variable: String
) on FIELD_DEFINITION

directive @dynamodbColumn(
	fieldName: String!
	fieldType: String!
	jsonName: String
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @dynamodbQuery(
	table: String!
	projectionExpression: String
	index: String
	limit: Int
	sortColumn: String
	sortAsc: Boolean
	scanIndexBackward: Boolean
	consistentRead: Boolean
	insert: Boolean
	update: Boolean
	delete: Boolean
	updateConditionExpression: String # valid dynamodb expression e.g. "fieldName = :id"
	updateConditionValues: [String!] # in format [":variable=type=value"] e.g. [":allocatedDate=N=0"]
	updateConditionError: String
	deleteConditionExpression: String # valid dynamodb expression e.g. "fieldName = :id"
	deleteConditionValues: [String!] # in format [":variable=type=value"] e.g. [":allocatedDate=N=0"]
	deleteConditionError: String
	preQueryPackage: String
	preQueryFunction: String
	postQueryPackage: String
	postQueryFunction: String
) on FIELD_DEFINITION

directive @dynamodbSubquery(
	foreignHashKey: String!
	foreignHashKeyRequired: Boolean!
	hashKeyModelName: String!
	hashKeyFieldName: String!
	hashKeyFieldType: String!
	parentHashKeyModelName: String!
	foreignRangeKey: String
	foreignRangeKeyRequired: Boolean
	rangeKeyModelName: String
	rangeKeyFieldName: String
	rangeKeyFieldType: String
	parentRangeKeyModelName: String
	className: String!
	table: String!
	limit: Int
) on FIELD_DEFINITION

directive @hash(fieldName: String!) on FIELD_DEFINITION

directive @immutable(errorMessage: String!) on FIELD_DEFINITION

# an immutable timestamp will not be changed automatically on update
directive @timestamp(immutable: Boolean!) on FIELD_DEFINITION

directive @uuid(hashKey: Boolean!) on FIELD_DEFINITION

directive @dynamodbHashKey on ARGUMENT_DEFINITION

directive @dynamodbRangeKey on ARGUMENT_DEFINITION

directive @example(value: String!) on ARGUMENT_DEFINITION

directive @mutationCondition(expression: String!) on ARGUMENT_DEFINITION

directive @arrayInputUnique(fieldName: String!, exceptionRegex: String) on ARGUMENT_DEFINITION

input TableIntFilterInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: [Int]
}

input TableStringFilterInput {
	ne: String
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	between: [String]
	beginsWith: String
}

input TableBooleanFilterInput {
	ne: Boolean
	eq: Boolean
}

input TableFloatFilterInput {
	ne: Float
	eq: Float
	le: Float
	lt: Float
	ge: Float
	gt: Float
	between: [Float]
}

input TableIntKeyInput {
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: [Int]
}

input TableStringKeyInput {
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	between: [String]
	beginsWith: String
}

input TableBooleanKeyInput {
	eq: Boolean
}

input TableFloatKeyInput {
	eq: Float
	le: Float
	lt: Float
	ge: Float
	gt: Float
	between: [Float]
}

schema {
  query: Query,
  mutation: Mutation
}
`, BuiltIn: false},
	{Name: "../schema.graphql", Input: `"""
This object represents fields of custom data type.
"""
type ApplicationCustomData {
	foo: String!
	bar: String!
}

"""
This object represents fields from custom data source.
"""
type ApplicationCustomSource {
	custom: [ApplicationCustomData!]
}

"""
This object represents a single Application Company.
"""
type ApplicationCompany {
	"primary key generated by the server"
	companyID: ID! @dynamodbColumn(fieldName: "companyId", fieldType: "S") @uuid(hashKey: true)
	"name of company"
	companyName: String! @dynamodbColumn(fieldName: "userName", fieldType: "S")
	"epoch millis timestamp"
	createDate: Int!
		@timestamp(immutable: true)
		@dynamodbColumn(fieldName: "createDate", fieldType: "N")
}

"""
This object represents a single Application User.
"""
type ApplicationUser {
	"primary key generated by the server"
	userID: ID! @dynamodbColumn(fieldName: "userId", fieldType: "S") @uuid(hashKey: true)
	"name of user"
	userName: String! @dynamodbColumn(fieldName: "userName", fieldType: "S")
	"companyID used to link a user to a company"
	companyID: String @dynamodbColumn(fieldName: "companyId", fieldType: "S")
	company: ApplicationCompany @dynamodbSubquery(
		parentHashKeyModelName: "UserID",
		foreignHashKeyRequired: false,
		foreignHashKey: "CompanyID",
		hashKeyFieldName: "companyId",
		hashKeyFieldType: "S",
		hashKeyModelName: "CompanyID",
		className: "ApplicationCompany"
		table: "application-company",
		limit: 1,
	)
	"epoch millis timestamp"
	createDate: Int!
		@timestamp(immutable: true)
		@dynamodbColumn(fieldName: "createDate", fieldType: "N")
	"return list of languages user speaks"
	languages: [ApplicationUserLanguage!]!
	  @dynamodbSubquery(
			parentHashKeyModelName: "UserID",
			foreignHashKeyRequired: true,
			foreignHashKey: "UserID",
			foreignRangeKey: "Language",
			hashKeyFieldName: "userId",
			hashKeyFieldType: "S",
			hashKeyModelName: "UserID",
			className: "ApplicationUserLanguage",
			table: "application-userLanguage",
			query: true,
		)
	"return opjects from custom source"
	customData: ApplicationCustomSource @customSubquery(
		package: "custom",
		function: "GetCustomData",
	)
}

"""
This object represents languages user's have command of.
"""
type ApplicationUserLanguage {
	"primary key generated by the server"
	userID: ID! @dynamodbColumn(fieldName: "userId", fieldType: "S")
	"language"
	userLanguage: String!
		@dynamodbColumn(fieldName: "userLanguage", fieldType: "S")
}

type Query {
	"""
	Return a Application User object from userID.
	"""
	getApplicationUser(
		"userID is the unique identifier for the user"
		userID: String! @dynamodbHashKey @example(value: "00000000-0000-0000-0000-000000000000")
	): ApplicationUserList!
		@authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-user"
		)

	"""
	Return a Application User object by userName.
	"""
	searchApplicationUser(
		"userName of the user"
		userName: String! @dynamodbHashKey @example(value: "craftycoder")
	): ApplicationUserList!
		@authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-user",
      index: "userName-index"
		)

	"""
	Return a list of all Application Company objects.
	"""
	listApplicationCompany: ApplicationCompanyList!
		@authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-company"
		)
}

type Mutation {
	"""
	Creates a new Application User object.
	"""
	createApplicationUser(
		"name of user"
		userName: String! @example(value: "testuser6")
		"companyId of the user"
		companyID: String! @example(value: "10101010-0000-0000-0000-000000000000")
	): ApplicationUserList!
    @authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-user"
			insert: true
			update: false
			consistentRead: true
		)

	"""
	Update an Application User object.
	"""
	updateApplicationUser(
    "userID is the unique identifier for the user"
		userID: String! @dynamodbHashKey @example(value: "00000000-0000-0000-0000-000000000000")
		"name of user"
		userName: String! @dynamodbRangeKey @example(value: "craftycoder")
		"companyId of the user"
		companyID: String! @example(value: "10101010-0000-0000-0000-000000000000")
	): ApplicationUserList!
    @authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-user"
			insert: false
			update: true
			consistentRead: true
		)

	"""
	Creates a new Application User Language object.
	"""
	createApplicationUserLanguage(
		"userID is the unique identifier for the user"
		userID: String! @dynamodbHashKey @example(value: "00000000-0000-0000-0000-000000000000")
		"language"
		userLanguage: String! @dynamodbRangeKey @example(value: "english")
	): ApplicationUserLanguageList!
    @authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-userLanguage"
			insert: true
			update: false
			consistentRead: true
		)

	"""
	Delete an Application User Language object.
	"""
	deleteApplicationUserLanguage(
    "userID is the unique identifier for the user"
		userID: String! @dynamodbHashKey @example(value: "00000000-0000-0000-0000-000000000000")
		"language"
		userLanguage: String! @dynamodbRangeKey @example(value: "english")
	): ApplicationUserLanguageList
    @authorizedRole(
			serviceRoles: ["service-one"]
			userRoles: ["system-admin"]
		)
		@dynamodbQuery(
			table: "application-userLanguage"
			insert: false
			update: false
      delete: true
			consistentRead: true
		)
}

"""
List of [ApplicationUser](#applicationuser) objects
[examples](https://github.com/craftyc0der/gqlgen-dynamodb/blob/master/graphql.md#applicationuser)
"""
type ApplicationUserList {
	items: [ApplicationUser!]!
}

"""
List of [ApplicationCompany](#applicationcompany) objects
[examples](https://github.com/craftyc0der/gqlgen-dynamodb/blob/master/graphql.md#applicationcompany)
"""
type ApplicationCompanyList {
	items: [ApplicationCompany!]!
}

"""
List of [ApplicationUserLanguage](#applicationuserlanguage) objects
[examples](https://github.com/craftyc0der/gqlgen-dynamodb/blob/master/graphql.md#applicationuserlanguage)
"""
type ApplicationUserLanguageList {
	items: [ApplicationUserLanguage!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_arrayInputUnique_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["fieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fieldName"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["exceptionRegex"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exceptionRegex"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["exceptionRegex"] = arg1
	return args, nil
}

func (ec *executionContext) dir_authorizedRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["serviceRoles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceRoles"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["serviceRoles"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["userRoles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userRoles"))
		arg1, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userRoles"] = arg1
	return args, nil
}

func (ec *executionContext) dir_customResolver_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["package"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["package"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["function"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("function"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["function"] = arg1
	return args, nil
}

func (ec *executionContext) dir_customSubquery_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["package"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["package"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["function"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("function"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["function"] = arg1
	return args, nil
}

func (ec *executionContext) dir_defaultValue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["envVar"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envVar"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envVar"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["static"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("static"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["static"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["variable"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variable"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["variable"] = arg2
	return args, nil
}

func (ec *executionContext) dir_dynamodbColumn_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["fieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fieldName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["fieldType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldType"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fieldType"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["jsonName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jsonName"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jsonName"] = arg2
	return args, nil
}

func (ec *executionContext) dir_dynamodbQuery_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["table"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("table"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["table"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["projectionExpression"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectionExpression"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectionExpression"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["index"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["index"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortColumn"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortColumn"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortColumn"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["sortAsc"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortAsc"))
		arg5, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortAsc"] = arg5
	var arg6 *bool
	if tmp, ok := rawArgs["scanIndexBackward"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scanIndexBackward"))
		arg6, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scanIndexBackward"] = arg6
	var arg7 *bool
	if tmp, ok := rawArgs["consistentRead"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consistentRead"))
		arg7, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["consistentRead"] = arg7
	var arg8 *bool
	if tmp, ok := rawArgs["insert"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("insert"))
		arg8, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["insert"] = arg8
	var arg9 *bool
	if tmp, ok := rawArgs["update"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("update"))
		arg9, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg9
	var arg10 *bool
	if tmp, ok := rawArgs["delete"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delete"))
		arg10, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["delete"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["updateConditionExpression"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateConditionExpression"))
		arg11, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateConditionExpression"] = arg11
	var arg12 []string
	if tmp, ok := rawArgs["updateConditionValues"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateConditionValues"))
		arg12, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateConditionValues"] = arg12
	var arg13 *string
	if tmp, ok := rawArgs["updateConditionError"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateConditionError"))
		arg13, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateConditionError"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["deleteConditionExpression"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deleteConditionExpression"))
		arg14, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deleteConditionExpression"] = arg14
	var arg15 []string
	if tmp, ok := rawArgs["deleteConditionValues"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deleteConditionValues"))
		arg15, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deleteConditionValues"] = arg15
	var arg16 *string
	if tmp, ok := rawArgs["deleteConditionError"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deleteConditionError"))
		arg16, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deleteConditionError"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["preQueryPackage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preQueryPackage"))
		arg17, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["preQueryPackage"] = arg17
	var arg18 *string
	if tmp, ok := rawArgs["preQueryFunction"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preQueryFunction"))
		arg18, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["preQueryFunction"] = arg18
	var arg19 *string
	if tmp, ok := rawArgs["postQueryPackage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postQueryPackage"))
		arg19, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postQueryPackage"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["postQueryFunction"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postQueryFunction"))
		arg20, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postQueryFunction"] = arg20
	return args, nil
}

func (ec *executionContext) dir_dynamodbSubquery_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["foreignHashKey"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foreignHashKey"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["foreignHashKey"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["foreignHashKeyRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foreignHashKeyRequired"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["foreignHashKeyRequired"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["hashKeyModelName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hashKeyModelName"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hashKeyModelName"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["hashKeyFieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hashKeyFieldName"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hashKeyFieldName"] = arg3
	var arg4 string
	if tmp, ok := rawArgs["hashKeyFieldType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hashKeyFieldType"))
		arg4, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hashKeyFieldType"] = arg4
	var arg5 string
	if tmp, ok := rawArgs["parentHashKeyModelName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentHashKeyModelName"))
		arg5, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["parentHashKeyModelName"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["foreignRangeKey"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foreignRangeKey"))
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["foreignRangeKey"] = arg6
	var arg7 *bool
	if tmp, ok := rawArgs["foreignRangeKeyRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foreignRangeKeyRequired"))
		arg7, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["foreignRangeKeyRequired"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["rangeKeyModelName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeKeyModelName"))
		arg8, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rangeKeyModelName"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["rangeKeyFieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeKeyFieldName"))
		arg9, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rangeKeyFieldName"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["rangeKeyFieldType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeKeyFieldType"))
		arg10, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rangeKeyFieldType"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["parentRangeKeyModelName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentRangeKeyModelName"))
		arg11, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["parentRangeKeyModelName"] = arg11
	var arg12 string
	if tmp, ok := rawArgs["className"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("className"))
		arg12, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["className"] = arg12
	var arg13 string
	if tmp, ok := rawArgs["table"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("table"))
		arg13, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["table"] = arg13
	var arg14 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg14, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg14
	return args, nil
}

func (ec *executionContext) dir_example_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg0
	return args, nil
}

func (ec *executionContext) dir_hash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["fieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fieldName"] = arg0
	return args, nil
}

func (ec *executionContext) dir_immutable_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["errorMessage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorMessage"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["errorMessage"] = arg0
	return args, nil
}

func (ec *executionContext) dir_mutationCondition_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["expression"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["expression"] = arg0
	return args, nil
}

func (ec *executionContext) dir_timestamp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["immutable"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("immutable"))
		arg0, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["immutable"] = arg0
	return args, nil
}

func (ec *executionContext) dir_uuid_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["hashKey"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hashKey"))
		arg0, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hashKey"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createApplicationUserLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbHashKey == nil {
				return nil, errors.New("directive dynamodbHashKey is not implemented")
			}
			return ec.directives.DynamodbHashKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "00000000-0000-0000-0000-000000000000")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["userLanguage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userLanguage"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbRangeKey == nil {
				return nil, errors.New("directive dynamodbRangeKey is not implemented")
			}
			return ec.directives.DynamodbRangeKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "english")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userLanguage"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createApplicationUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userName"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "testuser6")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive0, value)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["companyID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("companyID"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "10101010-0000-0000-0000-000000000000")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive0, value)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["companyID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteApplicationUserLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbHashKey == nil {
				return nil, errors.New("directive dynamodbHashKey is not implemented")
			}
			return ec.directives.DynamodbHashKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "00000000-0000-0000-0000-000000000000")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["userLanguage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userLanguage"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbRangeKey == nil {
				return nil, errors.New("directive dynamodbRangeKey is not implemented")
			}
			return ec.directives.DynamodbRangeKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "english")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userLanguage"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateApplicationUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbHashKey == nil {
				return nil, errors.New("directive dynamodbHashKey is not implemented")
			}
			return ec.directives.DynamodbHashKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "00000000-0000-0000-0000-000000000000")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["userName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userName"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbRangeKey == nil {
				return nil, errors.New("directive dynamodbRangeKey is not implemented")
			}
			return ec.directives.DynamodbRangeKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "craftycoder")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg1 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["companyID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("companyID"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "10101010-0000-0000-0000-000000000000")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive0, value)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg2 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["companyID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getApplicationUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbHashKey == nil {
				return nil, errors.New("directive dynamodbHashKey is not implemented")
			}
			return ec.directives.DynamodbHashKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "00000000-0000-0000-0000-000000000000")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_searchApplicationUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userName"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.DynamodbHashKey == nil {
				return nil, errors.New("directive dynamodbHashKey is not implemented")
			}
			return ec.directives.DynamodbHashKey(ctx, rawArgs, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			value, err := ec.unmarshalNString2string(ctx, "craftycoder")
			if err != nil {
				return nil, err
			}
			if ec.directives.Example == nil {
				return nil, errors.New("directive example is not implemented")
			}
			return ec.directives.Example(ctx, rawArgs, directive1, value)
		}

		tmp, err = directive2(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["userName"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ApplicationCompany_companyID(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCompany) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCompany_companyID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CompanyID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "companyId")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			hashKey, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Uuid == nil {
				return nil, errors.New("directive uuid is not implemented")
			}
			return ec.directives.Uuid(ctx, obj, directive1, hashKey)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCompany_companyID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCompany",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationCompany_companyName(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCompany) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCompany_companyName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CompanyName, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "userName")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCompany_companyName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCompany",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationCompany_createDate(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCompany) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCompany_createDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreateDate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			immutable, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Timestamp == nil {
				return nil, errors.New("directive timestamp is not implemented")
			}
			return ec.directives.Timestamp(ctx, obj, directive0, immutable)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "createDate")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "N")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive1, fieldName, fieldType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCompany_createDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCompany",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationCompanyList_items(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCompanyList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCompanyList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationCompany)
	fc.Result = res
	return ec.marshalNApplicationCompany2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompanyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCompanyList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCompanyList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "companyID":
				return ec.fieldContext_ApplicationCompany_companyID(ctx, field)
			case "companyName":
				return ec.fieldContext_ApplicationCompany_companyName(ctx, field)
			case "createDate":
				return ec.fieldContext_ApplicationCompany_createDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationCompany", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationCustomData_foo(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCustomData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCustomData_foo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Foo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCustomData_foo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCustomData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationCustomData_bar(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCustomData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCustomData_bar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bar, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCustomData_bar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCustomData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationCustomSource_custom(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationCustomSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationCustomSource_custom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Custom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationCustomData)
	fc.Result = res
	return ec.marshalOApplicationCustomData2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCustomDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationCustomSource_custom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationCustomSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "foo":
				return ec.fieldContext_ApplicationCustomData_foo(ctx, field)
			case "bar":
				return ec.fieldContext_ApplicationCustomData_bar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationCustomData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_userID(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "userId")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			hashKey, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Uuid == nil {
				return nil, errors.New("directive uuid is not implemented")
			}
			return ec.directives.Uuid(ctx, obj, directive1, hashKey)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_userName(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserName, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "userName")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_userName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_companyID(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_companyID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CompanyID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "companyId")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_companyID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_company(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_company(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Company, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			foreignHashKey, err := ec.unmarshalNString2string(ctx, "CompanyID")
			if err != nil {
				return nil, err
			}
			foreignHashKeyRequired, err := ec.unmarshalNBoolean2bool(ctx, false)
			if err != nil {
				return nil, err
			}
			hashKeyModelName, err := ec.unmarshalNString2string(ctx, "CompanyID")
			if err != nil {
				return nil, err
			}
			hashKeyFieldName, err := ec.unmarshalNString2string(ctx, "companyId")
			if err != nil {
				return nil, err
			}
			hashKeyFieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			parentHashKeyModelName, err := ec.unmarshalNString2string(ctx, "UserID")
			if err != nil {
				return nil, err
			}
			className, err := ec.unmarshalNString2string(ctx, "ApplicationCompany")
			if err != nil {
				return nil, err
			}
			table, err := ec.unmarshalNString2string(ctx, "application-company")
			if err != nil {
				return nil, err
			}
			limit, err := ec.unmarshalOInt2ᚖint(ctx, 1)
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbSubquery == nil {
				return nil, errors.New("directive dynamodbSubquery is not implemented")
			}
			return ec.directives.DynamodbSubquery(ctx, obj, directive0, foreignHashKey, foreignHashKeyRequired, hashKeyModelName, hashKeyFieldName, hashKeyFieldType, parentHashKeyModelName, nil, nil, nil, nil, nil, nil, className, table, limit)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationCompany); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationCompany`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationCompany)
	fc.Result = res
	return ec.marshalOApplicationCompany2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompany(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_company(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "companyID":
				return ec.fieldContext_ApplicationCompany_companyID(ctx, field)
			case "companyName":
				return ec.fieldContext_ApplicationCompany_companyName(ctx, field)
			case "createDate":
				return ec.fieldContext_ApplicationCompany_createDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationCompany", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_createDate(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_createDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreateDate, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			immutable, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.Timestamp == nil {
				return nil, errors.New("directive timestamp is not implemented")
			}
			return ec.directives.Timestamp(ctx, obj, directive0, immutable)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "createDate")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "N")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive1, fieldName, fieldType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_createDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_languages(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Languages, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			foreignHashKey, err := ec.unmarshalNString2string(ctx, "UserID")
			if err != nil {
				return nil, err
			}
			foreignHashKeyRequired, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			hashKeyModelName, err := ec.unmarshalNString2string(ctx, "UserID")
			if err != nil {
				return nil, err
			}
			hashKeyFieldName, err := ec.unmarshalNString2string(ctx, "userId")
			if err != nil {
				return nil, err
			}
			hashKeyFieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			parentHashKeyModelName, err := ec.unmarshalNString2string(ctx, "UserID")
			if err != nil {
				return nil, err
			}
			foreignRangeKey, err := ec.unmarshalOString2ᚖstring(ctx, "Language")
			if err != nil {
				return nil, err
			}
			className, err := ec.unmarshalNString2string(ctx, "ApplicationUserLanguage")
			if err != nil {
				return nil, err
			}
			table, err := ec.unmarshalNString2string(ctx, "application-userLanguage")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbSubquery == nil {
				return nil, errors.New("directive dynamodbSubquery is not implemented")
			}
			return ec.directives.DynamodbSubquery(ctx, obj, directive0, foreignHashKey, foreignHashKeyRequired, hashKeyModelName, hashKeyFieldName, hashKeyFieldType, parentHashKeyModelName, foreignRangeKey, nil, nil, nil, nil, nil, className, table, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ApplicationUserLanguage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserLanguage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationUserLanguage)
	fc.Result = res
	return ec.marshalNApplicationUserLanguage2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_languages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userID":
				return ec.fieldContext_ApplicationUserLanguage_userID(ctx, field)
			case "userLanguage":
				return ec.fieldContext_ApplicationUserLanguage_userLanguage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserLanguage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUser_customData(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUser_customData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CustomData, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			packageArg, err := ec.unmarshalNString2string(ctx, "custom")
			if err != nil {
				return nil, err
			}
			function, err := ec.unmarshalNString2string(ctx, "GetCustomData")
			if err != nil {
				return nil, err
			}
			if ec.directives.CustomSubquery == nil {
				return nil, errors.New("directive customSubquery is not implemented")
			}
			return ec.directives.CustomSubquery(ctx, obj, directive0, packageArg, function)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationCustomSource); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationCustomSource`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationCustomSource)
	fc.Result = res
	return ec.marshalOApplicationCustomSource2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCustomSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUser_customData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "custom":
				return ec.fieldContext_ApplicationCustomSource_custom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationCustomSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUserLanguage_userID(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUserLanguage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUserLanguage_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "userId")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUserLanguage_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUserLanguage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUserLanguage_userLanguage(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUserLanguage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUserLanguage_userLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UserLanguage, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			fieldName, err := ec.unmarshalNString2string(ctx, "userLanguage")
			if err != nil {
				return nil, err
			}
			fieldType, err := ec.unmarshalNString2string(ctx, "S")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbColumn == nil {
				return nil, errors.New("directive dynamodbColumn is not implemented")
			}
			return ec.directives.DynamodbColumn(ctx, obj, directive0, fieldName, fieldType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUserLanguage_userLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUserLanguage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUserLanguageList_items(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUserLanguageList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUserLanguageList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationUserLanguage)
	fc.Result = res
	return ec.marshalNApplicationUserLanguage2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUserLanguageList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUserLanguageList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userID":
				return ec.fieldContext_ApplicationUserLanguage_userID(ctx, field)
			case "userLanguage":
				return ec.fieldContext_ApplicationUserLanguage_userLanguage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserLanguage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationUserList_items(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationUserList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationUserList_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationUser)
	fc.Result = res
	return ec.marshalNApplicationUser2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationUserList_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationUserList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userID":
				return ec.fieldContext_ApplicationUser_userID(ctx, field)
			case "userName":
				return ec.fieldContext_ApplicationUser_userName(ctx, field)
			case "companyID":
				return ec.fieldContext_ApplicationUser_companyID(ctx, field)
			case "company":
				return ec.fieldContext_ApplicationUser_company(ctx, field)
			case "createDate":
				return ec.fieldContext_ApplicationUser_createDate(ctx, field)
			case "languages":
				return ec.fieldContext_ApplicationUser_languages(ctx, field)
			case "customData":
				return ec.fieldContext_ApplicationUser_customData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createApplicationUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createApplicationUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateApplicationUser(rctx, fc.Args["userName"].(string), fc.Args["companyID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-user")
			if err != nil {
				return nil, err
			}
			consistentRead, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			insert, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			update, err := ec.unmarshalOBoolean2ᚖbool(ctx, false)
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, nil, nil, nil, nil, nil, consistentRead, insert, update, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationUserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationUserList)
	fc.Result = res
	return ec.marshalNApplicationUserList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createApplicationUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationUserList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createApplicationUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateApplicationUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateApplicationUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateApplicationUser(rctx, fc.Args["userID"].(string), fc.Args["userName"].(string), fc.Args["companyID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-user")
			if err != nil {
				return nil, err
			}
			consistentRead, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			insert, err := ec.unmarshalOBoolean2ᚖbool(ctx, false)
			if err != nil {
				return nil, err
			}
			update, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, nil, nil, nil, nil, nil, consistentRead, insert, update, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationUserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationUserList)
	fc.Result = res
	return ec.marshalNApplicationUserList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateApplicationUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationUserList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateApplicationUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createApplicationUserLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createApplicationUserLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateApplicationUserLanguage(rctx, fc.Args["userID"].(string), fc.Args["userLanguage"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-userLanguage")
			if err != nil {
				return nil, err
			}
			consistentRead, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			insert, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			update, err := ec.unmarshalOBoolean2ᚖbool(ctx, false)
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, nil, nil, nil, nil, nil, consistentRead, insert, update, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationUserLanguageList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserLanguageList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationUserLanguageList)
	fc.Result = res
	return ec.marshalNApplicationUserLanguageList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createApplicationUserLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationUserLanguageList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserLanguageList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createApplicationUserLanguage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApplicationUserLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApplicationUserLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteApplicationUserLanguage(rctx, fc.Args["userID"].(string), fc.Args["userLanguage"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-userLanguage")
			if err != nil {
				return nil, err
			}
			consistentRead, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			insert, err := ec.unmarshalOBoolean2ᚖbool(ctx, false)
			if err != nil {
				return nil, err
			}
			update, err := ec.unmarshalOBoolean2ᚖbool(ctx, false)
			if err != nil {
				return nil, err
			}
			delete, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, nil, nil, nil, nil, nil, consistentRead, insert, update, delete, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationUserLanguageList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserLanguageList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationUserLanguageList)
	fc.Result = res
	return ec.marshalOApplicationUserLanguageList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApplicationUserLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationUserLanguageList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserLanguageList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApplicationUserLanguage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getApplicationUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getApplicationUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetApplicationUser(rctx, fc.Args["userID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-user")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationUserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationUserList)
	fc.Result = res
	return ec.marshalNApplicationUserList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getApplicationUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationUserList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getApplicationUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchApplicationUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchApplicationUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchApplicationUser(rctx, fc.Args["userName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-user")
			if err != nil {
				return nil, err
			}
			index, err := ec.unmarshalOString2ᚖstring(ctx, "userName-index")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, index, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationUserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationUserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationUserList)
	fc.Result = res
	return ec.marshalNApplicationUserList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchApplicationUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationUserList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationUserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchApplicationUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listApplicationCompany(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listApplicationCompany(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListApplicationCompany(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			serviceRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"service-one"})
			if err != nil {
				return nil, err
			}
			userRoles, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"system-admin"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AuthorizedRole == nil {
				return nil, errors.New("directive authorizedRole is not implemented")
			}
			return ec.directives.AuthorizedRole(ctx, nil, directive0, serviceRoles, userRoles)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			table, err := ec.unmarshalNString2string(ctx, "application-company")
			if err != nil {
				return nil, err
			}
			if ec.directives.DynamodbQuery == nil {
				return nil, errors.New("directive dynamodbQuery is not implemented")
			}
			return ec.directives.DynamodbQuery(ctx, nil, directive1, table, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ApplicationCompanyList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/craftyc0der/gqlgen-dynamodb/graph/model.ApplicationCompanyList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationCompanyList)
	fc.Result = res
	return ec.marshalNApplicationCompanyList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompanyList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listApplicationCompany(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ApplicationCompanyList_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationCompanyList", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputTableBooleanFilterInput(ctx context.Context, obj interface{}) (model.TableBooleanFilterInput, error) {
	var it model.TableBooleanFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ne", "eq"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ne":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ne"))
			it.Ne, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableBooleanKeyInput(ctx context.Context, obj interface{}) (model.TableBooleanKeyInput, error) {
	var it model.TableBooleanKeyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableFloatFilterInput(ctx context.Context, obj interface{}) (model.TableFloatFilterInput, error) {
	var it model.TableFloatFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ne", "eq", "le", "lt", "ge", "gt", "between"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ne":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ne"))
			it.Ne, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableFloatKeyInput(ctx context.Context, obj interface{}) (model.TableFloatKeyInput, error) {
	var it model.TableFloatKeyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "le", "lt", "ge", "gt", "between"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableIntFilterInput(ctx context.Context, obj interface{}) (model.TableIntFilterInput, error) {
	var it model.TableIntFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ne", "eq", "le", "lt", "ge", "gt", "between"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ne":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ne"))
			it.Ne, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableIntKeyInput(ctx context.Context, obj interface{}) (model.TableIntKeyInput, error) {
	var it model.TableIntKeyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "le", "lt", "ge", "gt", "between"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableStringFilterInput(ctx context.Context, obj interface{}) (model.TableStringFilterInput, error) {
	var it model.TableStringFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ne", "eq", "le", "lt", "ge", "gt", "between", "beginsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ne":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ne"))
			it.Ne, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "beginsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("beginsWith"))
			it.BeginsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTableStringKeyInput(ctx context.Context, obj interface{}) (model.TableStringKeyInput, error) {
	var it model.TableStringKeyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "le", "lt", "ge", "gt", "between", "beginsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			it.Eq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "le":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("le"))
			it.Le, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			it.Lt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ge":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ge"))
			it.Ge, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "gt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			it.Gt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "between":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("between"))
			it.Between, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "beginsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("beginsWith"))
			it.BeginsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationCompanyImplementors = []string{"ApplicationCompany"}

func (ec *executionContext) _ApplicationCompany(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationCompany) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationCompanyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationCompany")
		case "companyID":

			out.Values[i] = ec._ApplicationCompany_companyID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "companyName":

			out.Values[i] = ec._ApplicationCompany_companyName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDate":

			out.Values[i] = ec._ApplicationCompany_createDate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationCompanyListImplementors = []string{"ApplicationCompanyList"}

func (ec *executionContext) _ApplicationCompanyList(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationCompanyList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationCompanyListImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationCompanyList")
		case "items":

			out.Values[i] = ec._ApplicationCompanyList_items(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationCustomDataImplementors = []string{"ApplicationCustomData"}

func (ec *executionContext) _ApplicationCustomData(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationCustomData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationCustomDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationCustomData")
		case "foo":

			out.Values[i] = ec._ApplicationCustomData_foo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "bar":

			out.Values[i] = ec._ApplicationCustomData_bar(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationCustomSourceImplementors = []string{"ApplicationCustomSource"}

func (ec *executionContext) _ApplicationCustomSource(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationCustomSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationCustomSourceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationCustomSource")
		case "custom":

			out.Values[i] = ec._ApplicationCustomSource_custom(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationUserImplementors = []string{"ApplicationUser"}

func (ec *executionContext) _ApplicationUser(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationUser")
		case "userID":

			out.Values[i] = ec._ApplicationUser_userID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userName":

			out.Values[i] = ec._ApplicationUser_userName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "companyID":

			out.Values[i] = ec._ApplicationUser_companyID(ctx, field, obj)

		case "company":

			out.Values[i] = ec._ApplicationUser_company(ctx, field, obj)

		case "createDate":

			out.Values[i] = ec._ApplicationUser_createDate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "languages":

			out.Values[i] = ec._ApplicationUser_languages(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "customData":

			out.Values[i] = ec._ApplicationUser_customData(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationUserLanguageImplementors = []string{"ApplicationUserLanguage"}

func (ec *executionContext) _ApplicationUserLanguage(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationUserLanguage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationUserLanguageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationUserLanguage")
		case "userID":

			out.Values[i] = ec._ApplicationUserLanguage_userID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userLanguage":

			out.Values[i] = ec._ApplicationUserLanguage_userLanguage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationUserLanguageListImplementors = []string{"ApplicationUserLanguageList"}

func (ec *executionContext) _ApplicationUserLanguageList(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationUserLanguageList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationUserLanguageListImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationUserLanguageList")
		case "items":

			out.Values[i] = ec._ApplicationUserLanguageList_items(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationUserListImplementors = []string{"ApplicationUserList"}

func (ec *executionContext) _ApplicationUserList(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationUserList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationUserListImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationUserList")
		case "items":

			out.Values[i] = ec._ApplicationUserList_items(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createApplicationUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createApplicationUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateApplicationUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateApplicationUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createApplicationUserLanguage":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createApplicationUserLanguage(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteApplicationUserLanguage":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApplicationUserLanguage(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getApplicationUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getApplicationUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "searchApplicationUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchApplicationUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listApplicationCompany":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listApplicationCompany(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNApplicationCompany2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompanyᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ApplicationCompany) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationCompany2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompany(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationCompany2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompany(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationCompany) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationCompany(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationCompanyList2githubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompanyList(ctx context.Context, sel ast.SelectionSet, v model.ApplicationCompanyList) graphql.Marshaler {
	return ec._ApplicationCompanyList(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationCompanyList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompanyList(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationCompanyList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationCompanyList(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationCustomData2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCustomData(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationCustomData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationCustomData(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationUser2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ApplicationUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationUser2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationUser2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUser(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationUser(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationUserLanguage2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ApplicationUserLanguage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationUserLanguage2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApplicationUserLanguage2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguage(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationUserLanguage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationUserLanguage(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationUserLanguageList2githubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageList(ctx context.Context, sel ast.SelectionSet, v model.ApplicationUserLanguageList) graphql.Marshaler {
	return ec._ApplicationUserLanguageList(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationUserLanguageList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageList(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationUserLanguageList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationUserLanguageList(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationUserList2githubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserList(ctx context.Context, sel ast.SelectionSet, v model.ApplicationUserList) graphql.Marshaler {
	return ec._ApplicationUserList(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationUserList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserList(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationUserList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationUserList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplicationCompany2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCompany(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationCompany) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationCompany(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationCustomData2ᚕᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCustomDataᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ApplicationCustomData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationCustomData2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCustomData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOApplicationCustomSource2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationCustomSource(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationCustomSource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationCustomSource(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationUserLanguageList2ᚖgithubᚗcomᚋcraftyc0derᚋgqlgenᚑdynamodbᚋgraphᚋmodelᚐApplicationUserLanguageList(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationUserLanguageList) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationUserLanguageList(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2ᚕᚖfloat64(ctx context.Context, v interface{}) ([]*float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFloat2ᚖfloat64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2ᚕᚖfloat64(ctx context.Context, sel ast.SelectionSet, v []*float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOFloat2ᚖfloat64(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOInt2ᚕᚖint(ctx context.Context, v interface{}) ([]*int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt2ᚖint(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕᚖint(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2ᚖint(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
