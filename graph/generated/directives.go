// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"fmt"
	"regexp"
	"strconv"

	"github.com/99designs/gqlgen/codegen"
)

type Directive_ArrayInputUnique struct {
	FieldName      string
	ExceptionRegex string
}

func GetArrayInputUnique(directive *codegen.Directive) Directive_ArrayInputUnique {
	var arrayInputUnique Directive_ArrayInputUnique

	for _, arg := range directive.Args {

		if arg.Name == "fieldName" && arg.Value != interface{}(nil) {
			arrayInputUnique.FieldName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "exceptionRegex" && arg.Value != interface{}(nil) {
			arrayInputUnique.ExceptionRegex = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return arrayInputUnique
}

func ExtractArrayInputUnique(tag string) Directive_ArrayInputUnique {
	var arrayInputUnique Directive_ArrayInputUnique

	fieldName_res := regexp.MustCompile("fieldName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range fieldName_res {
		val := fieldName_res[i][1]
		arrayInputUnique.FieldName, _ = val, ""
		break
	}
	exceptionRegex_res := regexp.MustCompile("exceptionRegex:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range exceptionRegex_res {
		val := exceptionRegex_res[i][1]
		arrayInputUnique.ExceptionRegex, _ = val, ""
		break
	}

	return arrayInputUnique
}

type Directive_AuthorizedRole struct {
	ServiceRoles []string

	UserRoles []string
}

func GetAuthorizedRole(directive *codegen.Directive) Directive_AuthorizedRole {
	var authorizedRole Directive_AuthorizedRole

	for _, arg := range directive.Args {

		if arg.Name == "serviceRoles" && arg.Value != interface{}(nil) {
			for _, role := range arg.Value.([]interface{}) {
				authorizedRole.ServiceRoles = append(authorizedRole.ServiceRoles, role.(string))
			}
			continue
		}
		if arg.Name == "userRoles" && arg.Value != interface{}(nil) {
			for _, role := range arg.Value.([]interface{}) {
				authorizedRole.UserRoles = append(authorizedRole.UserRoles, role.(string))
			}
			continue
		}
	}
	return authorizedRole
}

func ExtractAuthorizedRole(tag string) Directive_AuthorizedRole {
	var authorizedRole Directive_AuthorizedRole

	serviceRoles_res := regexp.MustCompile("serviceRoles:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range serviceRoles_res {
		val := serviceRoles_res[i][1]
		authorizedRole.ServiceRoles, _ = append(authorizedRole.ServiceRoles, val), ""
		break
	}
	userRoles_res := regexp.MustCompile("userRoles:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range userRoles_res {
		val := userRoles_res[i][1]
		authorizedRole.UserRoles, _ = append(authorizedRole.UserRoles, val), ""
		break
	}

	return authorizedRole
}

type Directive_CustomResolver struct {
	Package  string
	Function string
}

func GetCustomResolver(directive *codegen.Directive) Directive_CustomResolver {
	var customResolver Directive_CustomResolver

	for _, arg := range directive.Args {

		if arg.Name == "package" && arg.Value != interface{}(nil) {
			customResolver.Package = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "function" && arg.Value != interface{}(nil) {
			customResolver.Function = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return customResolver
}

func ExtractCustomResolver(tag string) Directive_CustomResolver {
	var customResolver Directive_CustomResolver

	package_res := regexp.MustCompile("package:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range package_res {
		val := package_res[i][1]
		customResolver.Package, _ = val, ""
		break
	}
	function_res := regexp.MustCompile("function:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range function_res {
		val := function_res[i][1]
		customResolver.Function, _ = val, ""
		break
	}

	return customResolver
}

type Directive_CustomSubquery struct {
	Package  string
	Function string
}

func GetCustomSubquery(directive *codegen.Directive) Directive_CustomSubquery {
	var customSubquery Directive_CustomSubquery

	for _, arg := range directive.Args {

		if arg.Name == "package" && arg.Value != interface{}(nil) {
			customSubquery.Package = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "function" && arg.Value != interface{}(nil) {
			customSubquery.Function = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return customSubquery
}

func ExtractCustomSubquery(tag string) Directive_CustomSubquery {
	var customSubquery Directive_CustomSubquery

	package_res := regexp.MustCompile("package:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range package_res {
		val := package_res[i][1]
		customSubquery.Package, _ = val, ""
		break
	}
	function_res := regexp.MustCompile("function:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range function_res {
		val := function_res[i][1]
		customSubquery.Function, _ = val, ""
		break
	}

	return customSubquery
}

type Directive_DefaultValue struct {
	EnvVar   string
	Static   string
	Variable string
}

func GetDefaultValue(directive *codegen.Directive) Directive_DefaultValue {
	var defaultValue Directive_DefaultValue

	for _, arg := range directive.Args {

		if arg.Name == "envVar" && arg.Value != interface{}(nil) {
			defaultValue.EnvVar = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "static" && arg.Value != interface{}(nil) {
			defaultValue.Static = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "variable" && arg.Value != interface{}(nil) {
			defaultValue.Variable = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return defaultValue
}

func ExtractDefaultValue(tag string) Directive_DefaultValue {
	var defaultValue Directive_DefaultValue

	envVar_res := regexp.MustCompile("envVar:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range envVar_res {
		val := envVar_res[i][1]
		defaultValue.EnvVar, _ = val, ""
		break
	}
	static_res := regexp.MustCompile("static:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range static_res {
		val := static_res[i][1]
		defaultValue.Static, _ = val, ""
		break
	}
	variable_res := regexp.MustCompile("variable:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range variable_res {
		val := variable_res[i][1]
		defaultValue.Variable, _ = val, ""
		break
	}

	return defaultValue
}

type Directive_DynamodbColumn struct {
	FieldName string
	FieldType string
	JsonName  string
}

func GetDynamodbColumn(directive *codegen.Directive) Directive_DynamodbColumn {
	var dynamodbColumn Directive_DynamodbColumn

	for _, arg := range directive.Args {

		if arg.Name == "fieldName" && arg.Value != interface{}(nil) {
			dynamodbColumn.FieldName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "fieldType" && arg.Value != interface{}(nil) {
			dynamodbColumn.FieldType = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "jsonName" && arg.Value != interface{}(nil) {
			dynamodbColumn.JsonName = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return dynamodbColumn
}

func ExtractDynamodbColumn(tag string) Directive_DynamodbColumn {
	var dynamodbColumn Directive_DynamodbColumn

	fieldName_res := regexp.MustCompile("fieldName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range fieldName_res {
		val := fieldName_res[i][1]
		dynamodbColumn.FieldName, _ = val, ""
		break
	}
	fieldType_res := regexp.MustCompile("fieldType:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range fieldType_res {
		val := fieldType_res[i][1]
		dynamodbColumn.FieldType, _ = val, ""
		break
	}
	jsonName_res := regexp.MustCompile("jsonName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range jsonName_res {
		val := jsonName_res[i][1]
		dynamodbColumn.JsonName, _ = val, ""
		break
	}

	return dynamodbColumn
}

type Directive_DynamodbQuery struct {
	Table                string
	ProjectionExpression string
	Index                string
	Limit                int64

	SortColumn                string
	SortAsc                   bool
	ScanIndexBackward         bool
	ConsistentRead            bool
	Insert                    bool
	Update                    bool
	Delete                    bool
	UpdateConditionExpression string
	UpdateConditionValues     []string

	UpdateConditionError      string
	DeleteConditionExpression string
	DeleteConditionValues     []string

	DeleteConditionError string
	PreQueryPackage      string
	PreQueryFunction     string
	PostQueryPackage     string
	PostQueryFunction    string
}

func GetDynamodbQuery(directive *codegen.Directive) Directive_DynamodbQuery {
	var dynamodbQuery Directive_DynamodbQuery

	for _, arg := range directive.Args {

		if arg.Name == "table" && arg.Value != interface{}(nil) {
			dynamodbQuery.Table = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "projectionExpression" && arg.Value != interface{}(nil) {
			dynamodbQuery.ProjectionExpression = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "index" && arg.Value != interface{}(nil) {
			dynamodbQuery.Index = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "limit" && arg.Value != interface{}(nil) {
			dynamodbQuery.Limit = arg.Value.(int64)
			continue
		}
		if arg.Name == "sortColumn" && arg.Value != interface{}(nil) {
			dynamodbQuery.SortColumn = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "sortAsc" && arg.Value != interface{}(nil) {
			dynamodbQuery.SortAsc = arg.Value.(bool)
			continue
		}
		if arg.Name == "scanIndexBackward" && arg.Value != interface{}(nil) {
			dynamodbQuery.ScanIndexBackward = arg.Value.(bool)
			continue
		}
		if arg.Name == "consistentRead" && arg.Value != interface{}(nil) {
			dynamodbQuery.ConsistentRead = arg.Value.(bool)
			continue
		}
		if arg.Name == "insert" && arg.Value != interface{}(nil) {
			dynamodbQuery.Insert = arg.Value.(bool)
			continue
		}
		if arg.Name == "update" && arg.Value != interface{}(nil) {
			dynamodbQuery.Update = arg.Value.(bool)
			continue
		}
		if arg.Name == "delete" && arg.Value != interface{}(nil) {
			dynamodbQuery.Delete = arg.Value.(bool)
			continue
		}
		if arg.Name == "updateConditionExpression" && arg.Value != interface{}(nil) {
			dynamodbQuery.UpdateConditionExpression = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "updateConditionValues" && arg.Value != interface{}(nil) {
			for _, role := range arg.Value.([]interface{}) {
				dynamodbQuery.UpdateConditionValues = append(dynamodbQuery.UpdateConditionValues, role.(string))
			}
			continue
		}
		if arg.Name == "updateConditionError" && arg.Value != interface{}(nil) {
			dynamodbQuery.UpdateConditionError = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "deleteConditionExpression" && arg.Value != interface{}(nil) {
			dynamodbQuery.DeleteConditionExpression = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "deleteConditionValues" && arg.Value != interface{}(nil) {
			for _, role := range arg.Value.([]interface{}) {
				dynamodbQuery.DeleteConditionValues = append(dynamodbQuery.DeleteConditionValues, role.(string))
			}
			continue
		}
		if arg.Name == "deleteConditionError" && arg.Value != interface{}(nil) {
			dynamodbQuery.DeleteConditionError = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "preQueryPackage" && arg.Value != interface{}(nil) {
			dynamodbQuery.PreQueryPackage = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "preQueryFunction" && arg.Value != interface{}(nil) {
			dynamodbQuery.PreQueryFunction = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "postQueryPackage" && arg.Value != interface{}(nil) {
			dynamodbQuery.PostQueryPackage = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "postQueryFunction" && arg.Value != interface{}(nil) {
			dynamodbQuery.PostQueryFunction = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return dynamodbQuery
}

func ExtractDynamodbQuery(tag string) Directive_DynamodbQuery {
	var dynamodbQuery Directive_DynamodbQuery

	table_res := regexp.MustCompile("table:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range table_res {
		val := table_res[i][1]
		dynamodbQuery.Table, _ = val, ""
		break
	}
	projectionExpression_res := regexp.MustCompile("projectionExpression:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range projectionExpression_res {
		val := projectionExpression_res[i][1]
		dynamodbQuery.ProjectionExpression, _ = val, ""
		break
	}
	index_res := regexp.MustCompile("index:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range index_res {
		val := index_res[i][1]
		dynamodbQuery.Index, _ = val, ""
		break
	}
	limit_res := regexp.MustCompile("limit:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range limit_res {
		val := limit_res[i][1]
		dynamodbQuery.Limit, _ = strconv.ParseInt(val, 10, 64)
		break
	}
	sortColumn_res := regexp.MustCompile("sortColumn:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range sortColumn_res {
		val := sortColumn_res[i][1]
		dynamodbQuery.SortColumn, _ = val, ""
		break
	}
	sortAsc_res := regexp.MustCompile("sortAsc:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range sortAsc_res {
		val := sortAsc_res[i][1]
		dynamodbQuery.SortAsc, _ = strconv.ParseBool(val)
		break
	}
	scanIndexBackward_res := regexp.MustCompile("scanIndexBackward:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range scanIndexBackward_res {
		val := scanIndexBackward_res[i][1]
		dynamodbQuery.ScanIndexBackward, _ = strconv.ParseBool(val)
		break
	}
	consistentRead_res := regexp.MustCompile("consistentRead:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range consistentRead_res {
		val := consistentRead_res[i][1]
		dynamodbQuery.ConsistentRead, _ = strconv.ParseBool(val)
		break
	}
	insert_res := regexp.MustCompile("insert:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range insert_res {
		val := insert_res[i][1]
		dynamodbQuery.Insert, _ = strconv.ParseBool(val)
		break
	}
	update_res := regexp.MustCompile("update:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range update_res {
		val := update_res[i][1]
		dynamodbQuery.Update, _ = strconv.ParseBool(val)
		break
	}
	delete_res := regexp.MustCompile("delete:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range delete_res {
		val := delete_res[i][1]
		dynamodbQuery.Delete, _ = strconv.ParseBool(val)
		break
	}
	updateConditionExpression_res := regexp.MustCompile("updateConditionExpression:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range updateConditionExpression_res {
		val := updateConditionExpression_res[i][1]
		dynamodbQuery.UpdateConditionExpression, _ = val, ""
		break
	}
	updateConditionValues_res := regexp.MustCompile("updateConditionValues:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range updateConditionValues_res {
		val := updateConditionValues_res[i][1]
		dynamodbQuery.UpdateConditionValues, _ = append(dynamodbQuery.UpdateConditionValues, val), ""
		break
	}
	updateConditionError_res := regexp.MustCompile("updateConditionError:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range updateConditionError_res {
		val := updateConditionError_res[i][1]
		dynamodbQuery.UpdateConditionError, _ = val, ""
		break
	}
	deleteConditionExpression_res := regexp.MustCompile("deleteConditionExpression:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range deleteConditionExpression_res {
		val := deleteConditionExpression_res[i][1]
		dynamodbQuery.DeleteConditionExpression, _ = val, ""
		break
	}
	deleteConditionValues_res := regexp.MustCompile("deleteConditionValues:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range deleteConditionValues_res {
		val := deleteConditionValues_res[i][1]
		dynamodbQuery.DeleteConditionValues, _ = append(dynamodbQuery.DeleteConditionValues, val), ""
		break
	}
	deleteConditionError_res := regexp.MustCompile("deleteConditionError:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range deleteConditionError_res {
		val := deleteConditionError_res[i][1]
		dynamodbQuery.DeleteConditionError, _ = val, ""
		break
	}
	preQueryPackage_res := regexp.MustCompile("preQueryPackage:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range preQueryPackage_res {
		val := preQueryPackage_res[i][1]
		dynamodbQuery.PreQueryPackage, _ = val, ""
		break
	}
	preQueryFunction_res := regexp.MustCompile("preQueryFunction:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range preQueryFunction_res {
		val := preQueryFunction_res[i][1]
		dynamodbQuery.PreQueryFunction, _ = val, ""
		break
	}
	postQueryPackage_res := regexp.MustCompile("postQueryPackage:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range postQueryPackage_res {
		val := postQueryPackage_res[i][1]
		dynamodbQuery.PostQueryPackage, _ = val, ""
		break
	}
	postQueryFunction_res := regexp.MustCompile("postQueryFunction:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range postQueryFunction_res {
		val := postQueryFunction_res[i][1]
		dynamodbQuery.PostQueryFunction, _ = val, ""
		break
	}

	return dynamodbQuery
}

type Directive_DynamodbSubquery struct {
	ForeignHashKey          string
	ForeignHashKeyRequired  bool
	HashKeyModelName        string
	HashKeyFieldName        string
	HashKeyFieldType        string
	ParentHashKeyModelName  string
	ForeignRangeKey         string
	ForeignRangeKeyRequired bool
	RangeKeyModelName       string
	RangeKeyFieldName       string
	RangeKeyFieldType       string
	ParentRangeKeyModelName string
	ClassName               string
	Table                   string
	Limit                   int64
}

func GetDynamodbSubquery(directive *codegen.Directive) Directive_DynamodbSubquery {
	var dynamodbSubquery Directive_DynamodbSubquery

	for _, arg := range directive.Args {

		if arg.Name == "foreignHashKey" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ForeignHashKey = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "foreignHashKeyRequired" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ForeignHashKeyRequired = arg.Value.(bool)
			continue
		}
		if arg.Name == "hashKeyModelName" && arg.Value != interface{}(nil) {
			dynamodbSubquery.HashKeyModelName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "hashKeyFieldName" && arg.Value != interface{}(nil) {
			dynamodbSubquery.HashKeyFieldName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "hashKeyFieldType" && arg.Value != interface{}(nil) {
			dynamodbSubquery.HashKeyFieldType = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "parentHashKeyModelName" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ParentHashKeyModelName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "foreignRangeKey" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ForeignRangeKey = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "foreignRangeKeyRequired" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ForeignRangeKeyRequired = arg.Value.(bool)
			continue
		}
		if arg.Name == "rangeKeyModelName" && arg.Value != interface{}(nil) {
			dynamodbSubquery.RangeKeyModelName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "rangeKeyFieldName" && arg.Value != interface{}(nil) {
			dynamodbSubquery.RangeKeyFieldName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "rangeKeyFieldType" && arg.Value != interface{}(nil) {
			dynamodbSubquery.RangeKeyFieldType = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "parentRangeKeyModelName" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ParentRangeKeyModelName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "className" && arg.Value != interface{}(nil) {
			dynamodbSubquery.ClassName = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "table" && arg.Value != interface{}(nil) {
			dynamodbSubquery.Table = fmt.Sprintf("%v", arg.Value)
			continue
		}
		if arg.Name == "limit" && arg.Value != interface{}(nil) {
			dynamodbSubquery.Limit = arg.Value.(int64)
			continue
		}
	}
	return dynamodbSubquery
}

func ExtractDynamodbSubquery(tag string) Directive_DynamodbSubquery {
	var dynamodbSubquery Directive_DynamodbSubquery

	foreignHashKey_res := regexp.MustCompile("foreignHashKey:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range foreignHashKey_res {
		val := foreignHashKey_res[i][1]
		dynamodbSubquery.ForeignHashKey, _ = val, ""
		break
	}
	foreignHashKeyRequired_res := regexp.MustCompile("foreignHashKeyRequired:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range foreignHashKeyRequired_res {
		val := foreignHashKeyRequired_res[i][1]
		dynamodbSubquery.ForeignHashKeyRequired, _ = strconv.ParseBool(val)
		break
	}
	hashKeyModelName_res := regexp.MustCompile("hashKeyModelName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range hashKeyModelName_res {
		val := hashKeyModelName_res[i][1]
		dynamodbSubquery.HashKeyModelName, _ = val, ""
		break
	}
	hashKeyFieldName_res := regexp.MustCompile("hashKeyFieldName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range hashKeyFieldName_res {
		val := hashKeyFieldName_res[i][1]
		dynamodbSubquery.HashKeyFieldName, _ = val, ""
		break
	}
	hashKeyFieldType_res := regexp.MustCompile("hashKeyFieldType:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range hashKeyFieldType_res {
		val := hashKeyFieldType_res[i][1]
		dynamodbSubquery.HashKeyFieldType, _ = val, ""
		break
	}
	parentHashKeyModelName_res := regexp.MustCompile("parentHashKeyModelName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range parentHashKeyModelName_res {
		val := parentHashKeyModelName_res[i][1]
		dynamodbSubquery.ParentHashKeyModelName, _ = val, ""
		break
	}
	foreignRangeKey_res := regexp.MustCompile("foreignRangeKey:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range foreignRangeKey_res {
		val := foreignRangeKey_res[i][1]
		dynamodbSubquery.ForeignRangeKey, _ = val, ""
		break
	}
	foreignRangeKeyRequired_res := regexp.MustCompile("foreignRangeKeyRequired:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range foreignRangeKeyRequired_res {
		val := foreignRangeKeyRequired_res[i][1]
		dynamodbSubquery.ForeignRangeKeyRequired, _ = strconv.ParseBool(val)
		break
	}
	rangeKeyModelName_res := regexp.MustCompile("rangeKeyModelName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range rangeKeyModelName_res {
		val := rangeKeyModelName_res[i][1]
		dynamodbSubquery.RangeKeyModelName, _ = val, ""
		break
	}
	rangeKeyFieldName_res := regexp.MustCompile("rangeKeyFieldName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range rangeKeyFieldName_res {
		val := rangeKeyFieldName_res[i][1]
		dynamodbSubquery.RangeKeyFieldName, _ = val, ""
		break
	}
	rangeKeyFieldType_res := regexp.MustCompile("rangeKeyFieldType:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range rangeKeyFieldType_res {
		val := rangeKeyFieldType_res[i][1]
		dynamodbSubquery.RangeKeyFieldType, _ = val, ""
		break
	}
	parentRangeKeyModelName_res := regexp.MustCompile("parentRangeKeyModelName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range parentRangeKeyModelName_res {
		val := parentRangeKeyModelName_res[i][1]
		dynamodbSubquery.ParentRangeKeyModelName, _ = val, ""
		break
	}
	className_res := regexp.MustCompile("className:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range className_res {
		val := className_res[i][1]
		dynamodbSubquery.ClassName, _ = val, ""
		break
	}
	table_res := regexp.MustCompile("table:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range table_res {
		val := table_res[i][1]
		dynamodbSubquery.Table, _ = val, ""
		break
	}
	limit_res := regexp.MustCompile("limit:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range limit_res {
		val := limit_res[i][1]
		dynamodbSubquery.Limit, _ = strconv.ParseInt(val, 10, 64)
		break
	}

	return dynamodbSubquery
}

type Directive_Example struct {
	Value string
}

func GetExample(directive *codegen.Directive) Directive_Example {
	var example Directive_Example

	for _, arg := range directive.Args {

		if arg.Name == "value" && arg.Value != interface{}(nil) {
			example.Value = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return example
}

func ExtractExample(tag string) Directive_Example {
	var example Directive_Example

	value_res := regexp.MustCompile("value:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range value_res {
		val := value_res[i][1]
		example.Value, _ = val, ""
		break
	}

	return example
}

type Directive_Hash struct {
	FieldName string
}

func GetHash(directive *codegen.Directive) Directive_Hash {
	var hash Directive_Hash

	for _, arg := range directive.Args {

		if arg.Name == "fieldName" && arg.Value != interface{}(nil) {
			hash.FieldName = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return hash
}

func ExtractHash(tag string) Directive_Hash {
	var hash Directive_Hash

	fieldName_res := regexp.MustCompile("fieldName:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range fieldName_res {
		val := fieldName_res[i][1]
		hash.FieldName, _ = val, ""
		break
	}

	return hash
}

type Directive_Immutable struct {
	ErrorMessage string
}

func GetImmutable(directive *codegen.Directive) Directive_Immutable {
	var immutable Directive_Immutable

	for _, arg := range directive.Args {

		if arg.Name == "errorMessage" && arg.Value != interface{}(nil) {
			immutable.ErrorMessage = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return immutable
}

func ExtractImmutable(tag string) Directive_Immutable {
	var immutable Directive_Immutable

	errorMessage_res := regexp.MustCompile("errorMessage:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range errorMessage_res {
		val := errorMessage_res[i][1]
		immutable.ErrorMessage, _ = val, ""
		break
	}

	return immutable
}

type Directive_MutationCondition struct {
	Expression string
}

func GetMutationCondition(directive *codegen.Directive) Directive_MutationCondition {
	var mutationCondition Directive_MutationCondition

	for _, arg := range directive.Args {

		if arg.Name == "expression" && arg.Value != interface{}(nil) {
			mutationCondition.Expression = fmt.Sprintf("%v", arg.Value)
			continue
		}
	}
	return mutationCondition
}

func ExtractMutationCondition(tag string) Directive_MutationCondition {
	var mutationCondition Directive_MutationCondition

	expression_res := regexp.MustCompile("expression:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range expression_res {
		val := expression_res[i][1]
		mutationCondition.Expression, _ = val, ""
		break
	}

	return mutationCondition
}

type Directive_Timestamp struct {
	Immutable bool
}

func GetTimestamp(directive *codegen.Directive) Directive_Timestamp {
	var timestamp Directive_Timestamp

	for _, arg := range directive.Args {

		if arg.Name == "immutable" && arg.Value != interface{}(nil) {
			timestamp.Immutable = arg.Value.(bool)
			continue
		}
	}
	return timestamp
}

func ExtractTimestamp(tag string) Directive_Timestamp {
	var timestamp Directive_Timestamp

	immutable_res := regexp.MustCompile("immutable:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range immutable_res {
		val := immutable_res[i][1]
		timestamp.Immutable, _ = strconv.ParseBool(val)
		break
	}

	return timestamp
}

type Directive_Uuid struct {
	HashKey bool
}

func GetUuid(directive *codegen.Directive) Directive_Uuid {
	var uuid Directive_Uuid

	for _, arg := range directive.Args {

		if arg.Name == "hashKey" && arg.Value != interface{}(nil) {
			uuid.HashKey = arg.Value.(bool)
			continue
		}
	}
	return uuid
}

func ExtractUuid(tag string) Directive_Uuid {
	var uuid Directive_Uuid

	hashKey_res := regexp.MustCompile("hashKey:([a-zA-Z0-9-]*)").FindAllStringSubmatch(tag, 1)
	for i := range hashKey_res {
		val := hashKey_res[i][1]
		uuid.HashKey, _ = strconv.ParseBool(val)
		break
	}

	return uuid
}
