package markdown

import (
	_ "embed"
	"fmt"
	"path/filepath"
	"strings"
	"syscall"
	"text/template"

	"github.com/craftyc0der/gqlgen-dynamodb/internal/code"
	"github.com/vektah/gqlparser/v2/ast"

	"github.com/99designs/gqlgen/codegen"
	"github.com/99designs/gqlgen/codegen/config"
	"github.com/99designs/gqlgen/codegen/templates"
	"github.com/99designs/gqlgen/plugin"
)

//go:embed markdown.gotpl
var markdownTemplate string
var prefixes []string

func New(filename string, typename string, tablePrefixes []string) plugin.Plugin {
	prefixes = tablePrefixes
	return &Plugin{filename: filename, typeName: typename}
}

type Plugin struct {
	filename string
	typeName string
}

var _ plugin.CodeGenerator = &Plugin{}
var _ plugin.ConfigMutator = &Plugin{}

func (m *Plugin) Name() string {
	return "markdown"
}

func (m *Plugin) MutateConfig(cfg *config.Config) error {
	_ = syscall.Unlink(m.filename)
	return nil
}

func (m *Plugin) GenerateCode(data *codegen.Data) error {
	abs, err := filepath.Abs(m.filename)
	if err != nil {
		return err
	}
	pkgName := code.NameForDir(filepath.Dir(abs))

	funcMap := template.FuncMap{
		// The name "title" is what the function will be called in the template text.
		"generateOutputFields":   GenerateOutputFields,
		"generateExample":        GenerateExample,
		"generateRoles":          GenerateRoles,
		"selectTypes":            SelectTypes,
		"generateRelatedQueries": GenerateRelatedQueries,
		"generateRelatedType":    GenerateRelatedType,
		"lc":                     LowerCase,
	}

	return templates.Render(templates.Options{
		PackageName:     pkgName,
		Filename:        m.filename,
		GeneratedHeader: false,
		PackageDoc:      "<!--- DO NOT EDIT: This file is automatically generated by markdown plugin\n",
		Data: &MarkdownBuild{
			Data:     data,
			TypeName: m.typeName,
		},
		Packages: data.Config.Packages,
		Funcs:    funcMap,
		Template: markdownTemplate,
	})
}

// GenerateOutputFields recursively outputs the fields for the given query
func GenerateOutputFields(data map[string]*config.TypeReference, parentField *ast.FieldDefinition, depth int) string {
	var fields []string
	for _, field := range data {
		if parentField.Type.Elem != nil && parentField.Type.Elem.NamedType != "String" {
			if field.Definition.Name == parentField.Type.Elem.NamedType {
				fields = append(fields, fmt.Sprintf("%v {", parentField.Name))
				// loop over field.Definition.Fields
				for _, subfield := range field.Definition.Fields {
					fields = append(fields, fmt.Sprintf("  %v", GenerateOutputFields(data, subfield, depth+1)))
				}
				fields = append(fields, "}")
				return strings.Join(fields, fmt.Sprintf("\n%v", strings.Repeat("  ", depth+2)))
			}
		} else if parentField.Type.NamedType != "String" &&
			parentField.Type.NamedType != "ID" &&
			parentField.Type.NamedType != "Int" &&
			parentField.Type.NamedType != "Float" &&
			parentField.Type.NamedType != "Boolean" {
			if field.Definition.Name == parentField.Type.NamedType {
				fields = append(fields, fmt.Sprintf("%v {", parentField.Name))
				// loop over field.Definition.Fields
				for _, subfield := range field.Definition.Fields {
					fields = append(fields, fmt.Sprintf("  %v", GenerateOutputFields(data, subfield, depth+1)))
				}
				fields = append(fields, "}")
				return strings.Join(fields, fmt.Sprintf("\n%v", strings.Repeat("  ", depth+2)))
			}
		}
	}
	return parentField.Name
}

// GenerateExample outputs the example for the given query
func GenerateExample(argument *ast.ArgumentDefinition) string {
	// loop over Directives, extract the value of directive named example
	value := ""
	for _, directive := range argument.Directives {
		if directive.Name == "example" {
			value = directive.Arguments[0].Value.Raw
		}
	}
	if argument.Type.NamedType == "String" {
		return fmt.Sprintf("\"%v\"", value)
	} else if strings.HasSuffix(argument.Type.NamedType, "FilterInput") {
		return fmt.Sprintf("{ %v }", value)
	}
	return value
}

// GenerateRoles outputs the roles for the given query
func GenerateRoles(arg *codegen.FieldArgument) string {
	value := ""
	if arg.VarName == "role" {
		// cast arg.Value to []string
		castvalue := arg.Value.([]interface{})
		for _, role := range castvalue {
			value += fmt.Sprintf("* %v\n", role)
		}
	}
	return value
}

// SelectTypes returns true if it is a custom type
func SelectTypes(ourtype *ast.Definition) bool {
	// create a string array of prefixes
	// loop over prefixes
	for _, prefix := range prefixes {
		if strings.HasPrefix(ourtype.Name, prefix) && !strings.HasSuffix(ourtype.Name, "List") {
			if ourtype.Kind == "OBJECT" {
				return true
			}
		}
	}
	return false
}

// GenerateRelatedQueries outputs a list of related queries
func GenerateRelatedQueries(field *codegen.Field, typeName string) string {
	value := ""
	if field.TypeReference.Definition.Name == typeName+"List" {
		value = fmt.Sprintf("* [%v](#%v)\n", field.GoFieldName, strings.ToLower(field.GoFieldName))
	}
	return value
}

// GenerateRelatedType outputs a list of related queries
func GenerateRelatedType(types map[string]*config.TypeReference, outputTypeName string) string {
	value := ""
	//loop over types as ourtype
	for _, ourtype := range types {
		if ourtype.Definition.Name+"List" == outputTypeName {
			value = fmt.Sprintf("* [%v](#%v)\n", ourtype.Definition.Name, strings.ToLower(ourtype.Definition.Name))
			return value
		}
	}
	return value
}

func LowerCase(input string) string {
	return strings.ToLower(input)
}

type MarkdownBuild struct {
	*codegen.Data
	TypeName string
}
